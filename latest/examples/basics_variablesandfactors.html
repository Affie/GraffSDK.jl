<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Building Graphs · GraffSDK.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>GraffSDK.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Getting Started</span><ul><li><a class="toctext" href="../getting_started.html">Introduction</a></li><li><a class="toctext" href="../handling_errors.html">Making Robust Calls</a></li><li><a class="toctext" href="../ref_common.html">Common Structures and Functions</a></li><li><a class="toctext" href="../working_with_data.html">Working with Data</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="examples.html">Introduction</a></li><li><a class="toctext" href="basics_initialization.html">Basic Initialization</a></li><li><a class="toctext" href="basics_robot.html">Basic Robot</a></li><li><a class="toctext" href="basics_session.html">Basic Session</a></li><li class="current"><a class="toctext" href="basics_variablesandfactors.html">Building Graphs</a><ul class="internal"><li><a class="toctext" href="#A-Quick-Discussion-on-IsReady-1">A Quick Discussion on IsReady</a></li><li><a class="toctext" href="#High-Level-Convenience-Functions-for-Adding-Data-to-a-Graff-1">High-Level Convenience Functions for Adding Data to a Graff</a></li><li><a class="toctext" href="#Low-Level-Functions-for-Adding-Data-to-a-Graff-1">Low-Level Functions for Adding Data to a Graff</a></li></ul></li></ul></li><li><span class="toctext">End-to-End Examples</span><ul><li><a class="toctext" href="hexagonal.html">Hexagonal Robot</a></li><li><a class="toctext" href="brookstone.html">Brookstone Rover</a></li></ul></li><li><span class="toctext">Service Reference</span><ul><li><a class="toctext" href="../ref_user.html">User Service</a></li><li><a class="toctext" href="../ref_robot.html">Robot Service</a></li><li><a class="toctext" href="../ref_session.html">Session Service</a></li></ul></li><li><a class="toctext" href="../reference.html">Reference</a></li></ul></nav><article id="docs"><header><nav><ul><li>Examples</li><li><a href="basics_variablesandfactors.html">Building Graphs</a></li></ul><a class="edit-page" href="https://github.com/GearsAD/GraffSDK.jl/blob/master/docs/src/examples/basics_variablesandfactors.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Building Graphs</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Adding-Variables-and-Factors-(Building-Graphs)-1" href="#Adding-Variables-and-Factors-(Building-Graphs)-1">Adding Variables and Factors (Building Graphs)</a></h1><p>Irrespective of your application - real-time robotics, batch processing of survey data, or really complex multi-hypothesis modeling - you&#39;re going to need to need to add factors and variables to a graph. This section discusses how to do that with SlamInDb/Graff:</p><ul><li><p>For the frequently-occurring cases, like streaming robotics, we have added convenience methods. We will also continue to do so for other scenarios, hopefully incrementally building easier/cleaner libraries and expertise for the wide variety of solutions that SlamInDb/Graff can solve. Right now, we have a convenience methods for building graphs from streams of odometry data (e.g. an LCM log or a ROS bag file).  </p></li><li><p>We also have lower-level methods, more generalized calls to add variables and factors.</p></li></ul><h2><a class="nav-anchor" id="A-Quick-Discussion-on-IsReady-1" href="#A-Quick-Discussion-on-IsReady-1">A Quick Discussion on IsReady</a></h2><p>Ideally, we want to solve any updated graph as quickly as possible. We&#39;re actually architecting the underlying solver structure to do that the moment new data becomes available, so in an ideal world, there is no such thing as a ready graph that doesn&#39;t have a solution yet.</p><p>However, in some scenarios you want to incrementally build graphs and then let it solve. The IsReady flag on variables provides you with a means to delay that solving.</p><p>In a simple scenario, imagine that you want to add two variables (x1 and x2) and relate them with a shared landmark. You may want to delay solving until you&#39;ve provided all the information. This can be done with the IsReady flag:</p><ul><li><p>Add x1 pose with isReady = false</p></li><li><p>Add x2 pose with isReady = false</p></li><li><p>Add l1 landmark with isReady = false</p></li><li><p>Create odometry factor between x1 and x2 (I moved from x1 to x2 and the new factor contains the odometry difference)</p></li><li><p>Create bearing+range factor between x1 and l1 (I saw something in x1)</p></li><li><p>Create bearing+range factor between x2 and l1 (I saw the same something in x2)</p></li><li><p>Call PutReady for this set of nodes</p></li><li><p>-&gt; Solver will detect new data and run off to solve it</p></li></ul><p>Last note of this: Some methods automatically set IsReady to true (such as the addOdometryMeasurement convenience functions) - this is great for examples and continuous incremental solving. That means that you don&#39;t need to worry about it, and when we discuss those methods we&#39;ll try indicate which automatically set it.</p><h2><a class="nav-anchor" id="High-Level-Convenience-Functions-for-Adding-Data-to-a-Graff-1" href="#High-Level-Convenience-Functions-for-Adding-Data-to-a-Graff-1">High-Level Convenience Functions for Adding Data to a Graff</a></h2><h3><a class="nav-anchor" id="Adding-Odometry-Data-1" href="#Adding-Odometry-Data-1">Adding Odometry Data</a></h3><p>Adding odometry data creates everything all at once for a standard 2D factor of type (x, y, angle). It creates a new variable (say x2) at the end of the graph, links it to the last variable (x1) via a Pose2Pose2 factor, and updates IsReady flags to true.</p><p>Just create the AddOdometryRequest request and fire it off:</p><pre><code class="language-julia">deltaMeasurement = [1.0; 1.0; pi/4] # x2&#39;s pose is (1, 1) away from x1 and the bearing increased by 45 degrees   
pOdo = Float64[0.1 0 0; 0 0.1 0; 0 0 0.01] # Uncertainty in the measurement is in pOdo along the principal diagonal, i.e. [0.1, 0.1, 0.01]
newOdo = AddOdometryRequest(deltaMeasurement, pOdo)
@show addOdoResponse = addOdometryMeasurement(synchronyConfig, newOdo)

# Above would produce x1 in an empty graph.
# Let&#39;s run again to produce x2 - assuming the robot travelled the same delta measurement
@show addOdoResponse = addOdometryMeasurement(synchronyConfig, newOdo)</code></pre><p>The result would be the following image if run against an empty session:</p><p><img src="images/x0_x2_nodes.jpg" alt="Simple Odometry Graph"/></p><h3><a class="nav-anchor" id="Adding-and-Attaching-Landmarks-1" href="#Adding-and-Attaching-Landmarks-1">Adding and Attaching Landmarks</a></h3><p>We may have seen the same identifying feature in both x1 and x2 (eg. an AprilTag), and want to represent this information. There is a convenience function addBearingRangeFactor that is used to add the factor between the landmark and the variable.</p><p>Technically adding landmarks is a lower-level function (addVariable), but in this scenario we want to show the binding of the landmark to variables, so we need to add a landmark with a addVariable call:</p><pre><code class="language-julia">newLandmark = VariableRequest(
  &quot;l1&quot;, #The variables label
  &quot;Point2&quot;, #The type of variable - in this instance it&#39;s a 2D point in space, refer to Variable Types section below for the other variable types
  [&quot;LANDMARK&quot;]) #Labels - we are identifying this as a landmark for readability
response = addVariable(synchronyConfig, newLandmark)</code></pre><p>We now create the factors to link x1 to l1, and x2 to l1 respectively. The factors are type specific (in this case, relating a 2D position+angle to a 2D point), and include a distribution capturing the uncertainty. You don&#39;t need to make them normal distributions, but that&#39;s a discussion for later:</p><pre><code class="language-julia">newBearingRangeFactor = BearingRangeRequest(&quot;x1&quot;, &quot;l1&quot;,
                          DistributionRequest(&quot;Normal&quot;, Float64[0; 0.1]), # A statistical measurement of the bearing from x2 to l1 - normal distribution with 0 mean and 0.1 std
                          DistributionRequest(&quot;Normal&quot;, Float64[20; 1.0]) # A statistical measurement of the range/distance from x2 to l1 - normal distribution with 0 mean and 0.1 std
                          )
addBearingRangeFactor(synchronyConfig, newBearingRangeFactor)</code></pre><p>We can add another one between x2 and l1:</p><pre><code class="language-julia">newBearingRangeFactor = BearingRangeRequest(&quot;x2&quot;, &quot;l1&quot;,
                          DistributionRequest(&quot;Normal&quot;, Float64[-pi/4; 0.1]), # A statistical measurement of the bearing from x1 to l1 - normal distribution with 0 mean and 0.1 std
                          DistributionRequest(&quot;Normal&quot;, Float64[18; 1.0]) # A statistical measurement of the range/distance from x1 to l1 - normal distribution with 0 mean and 0.1 std
                          )
addBearingRangeFactor(synchronyConfig, newBearingRangeFactor)</code></pre><p>The graph then becomes:</p><p><img src="images/x0_x2_l1_nodes.png" alt="Odometry Graph with bound landmark"/></p><h3><a class="nav-anchor" id="Attaching-Sensor-Data-1" href="#Attaching-Sensor-Data-1">Attaching Sensor Data</a></h3><p>[TODO]</p><h2><a class="nav-anchor" id="Low-Level-Functions-for-Adding-Data-to-a-Graff-1" href="#Low-Level-Functions-for-Adding-Data-to-a-Graff-1">Low-Level Functions for Adding Data to a Graff</a></h2><h3><a class="nav-anchor" id="Adding-Variables-1" href="#Adding-Variables-1">Adding Variables</a></h3><p>Variables (a.k.a. poses in localization terminology) are created in the same way  shown above for the landmark. Variables contain a label, a data type (e.g. a 2D Point or Pose). Note that variables are solved - i.e. they are the product, what you wish to calculate when the solver runs - so you don&#39;t provide any measurements when creating them.</p><p>For example, we can define x1 as follows:</p><pre><code class="language-julia">x1Request = VariableRequest(&quot;x1&quot;, &quot;Pose2&quot;)
response = addVariable(synchronyConfig, x1Request)

x2Request = VariableRequest(&quot;x2&quot;, &quot;Pose2&quot;, [&quot;AdditionalLabel&quot;])
response = addVariable(synchronyConfig, x2Request)</code></pre><p>We can also provide additional labels in the request, as was done with the landmark, to help identify the variables later:</p><pre><code class="language-julia">newLandmark = VariableRequest(&quot;l1&quot;, &quot;Point2&quot;, [&quot;LANDMARK&quot;])
response = addVariable(synchronyConfig, newLandmark)</code></pre><p>NOTE: These are by default created with IsReady set to false. The assumption is that you are building lower-level elements, so you should call putReady once you want these nodes to be solved.</p><h4><a class="nav-anchor" id="Variable-Types-1" href="#Variable-Types-1">Variable Types</a></h4><p>If you have installed RoME, you can check for the latest variable types with:</p><pre><code class="language-julia">using RoME
subtypes(IncrementalInference.InferenceVariable)</code></pre><p>The current list of available variable types is:</p><ul><li><p>Point2 - A 2D coordinate</p></li><li><p>Point3 - A 3D coordinate</p></li><li><p>Pose2 - A 2D coordinate and a rotation (i.e. bearing)</p></li><li><p>Pose3 - A 3D coordinate and 3 associated rotations</p></li><li><p>DynPoint2 - A 2D coordinate and linear velocities</p></li><li><p>DynPose2 - A 2D coordinate, linear velocities, and a rotation</p></li></ul><h3><a class="nav-anchor" id="Adding-Factors-1" href="#Adding-Factors-1">Adding Factors</a></h3><h4><a class="nav-anchor" id="Creating-Factors-with-RoME-1" href="#Creating-Factors-with-RoME-1">Creating Factors with RoME</a></h4><p>If you have RoME installed, you can lever the RoME library for creating various factors. To continue the prior example, to create the Pose2-&gt;Pose2 odometry relationship:</p><pre><code class="language-julia">using RoME
using Distributions

# Our measurements
deltaMeasurement = [1.0; 1.0; pi/4] #Same as above - a (1,1) move with a 45 degree heading change
pOdo = Float64[0.1 0 0; 0 0.1 0; 0 0 0.01]
# Creating the factor body - We are working on making this cleaner
p2p2 = Pose2Pose2(MvNormal(deltaMeasurement, pOdo.^2))
p2p2Conv = convert(PackedPose2Pose2, p2p2)
p2p2Request = FactorRequest([&quot;x0&quot;, &quot;x1&quot;], &quot;Pose2Pose2&quot;, p2p2Conv)

# Send the request for the x0-&gt;x1 link
addFactor(synchronyConfig, p2p2Request)
# Update the request to make the same link between x1 and x2
p2p2Request.variables = [&quot;x1&quot;, &quot;x2&quot;]
addFactor(synchronyConfig, p2p2Request)</code></pre><p>Now we can add the factors between the variables and the landmark. As above, this is a 2D pose to 2D point+bearing factor, and is built similar to above:</p><pre><code class="language-julia"># Lastly, let&#39;s add the bearing+range factor between x1 and landmark l1
bearingDist = Normal(-pi/4, 0.1)
rangeDist = Normal(18, 1.0)
p2br2 = Pose2Point2BearingRange(bearingDist, rangeDist)
p2br2Conv = convert(PackedPose2Point2BearingRange, p2br2)
p2br2Request = FactorRequest([&quot;x1&quot;, &quot;l1&quot;], &quot;Pose2Point2BearingRange&quot;, p2br2Conv)

addFactor(synchronyConfig, p2br2Request)
# Now add the x1-&gt;l1 bearing+range factor
p2br2Request.variables = [&quot;x2&quot;, &quot;l1&quot;]
addFactor(synchronyConfig, p2br2Request)</code></pre><h4><a class="nav-anchor" id="Creating-Factors-Natively-1" href="#Creating-Factors-Natively-1">Creating Factors Natively</a></h4><p>[TODO] In some instances, you are running a parallel local solver, so RoME will be available for factor creation. In other, smaller instances, you may rely solely on the cloud solution. In this case, you need to create factors without pulling in RoME. TBD - Still working on this.</p><h4><a class="nav-anchor" id="Factor-Types-1" href="#Factor-Types-1">Factor Types</a></h4><p>If you have installed RoME, you can check for the latest factor types with:</p><pre><code class="language-julia">using RoME
subtypes(IncrementalInference.FunctorPairwise)</code></pre><p>The current factor types that you will find in the example are (there are many aside from these):</p><ul><li><p>Point2Point2 -A factor between two 2D points</p></li><li><p>Point2Point2WorldBearing - A factor between two 2D points with bearing</p></li><li><p>Pose2Point2Bearing - A factor between two 2D points with bearing</p></li><li><p>Pose2Point2BearingRange - A factor between two 2D points with bearing and range</p></li><li><p>Pose2Point2Range - A factor between a 2D pose and a 2D point, with range</p></li><li><p>Pose2Pose2 - A factor between two 2D poses</p></li><li><p>Pose3Pose3 - A factor between two 3D poses</p></li></ul><footer><hr/><a class="previous" href="basics_session.html"><span class="direction">Previous</span><span class="title">Basic Session</span></a><a class="next" href="hexagonal.html"><span class="direction">Next</span><span class="title">Hexagonal Robot</span></a></footer></article></body></html>
